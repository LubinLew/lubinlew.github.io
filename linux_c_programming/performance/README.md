# 程序性能优化

> [极致优化：如何实现高性能的 C 程序？-极客时间](https://time.geekbang.org/column/article/481903)

## 提高缓存命中率

> [Gallery of Processor Cache Effects](http://igoro.com/archive/gallery-of-processor-cache-effects/)

程序运行时需要使用CPU的寄存器、L1高速缓存、L2高速缓存、L3高速缓存 和 内存。按照读写速度来说，[寄存器的速度远高于 L1～L3高速缓存，高速缓存的速度远高于内存](https://www.zhihu.com/question/20075426)，但是存储量确实反过来的，一颗CPU只有几十个寄存器(寄存器通常都是32/64位的)，高速缓存从几兆到几十兆不等(高速缓存的大小也是衡量CPU性能的一环)，而内存在服务器上都是几百G，甚至上T。

高速缓存之所以能够提升性能，一个重要的前提便在于“局部性（locality）原理”。该原理通常被分为两个方面，即“时间局部性”和“空间局部性”，它们的内容分别如下所示。

- 时间局部性：被引用过一次的内存位置可能在不远的将来会再被多次引用；

- 空间局部性：如果一个内存位置被引用了一次，那么程序很可能在不久的将来引用其附近的另一个内存位置。

在计算机内部，高速缓存是以“缓存行（Cache Line）”的形式被组织的。也就是说，一大块连续的高速缓存会被分为多个组，每个组中有多个行，而每个行则具有固定大小。当发生缓存不命中时，CPU 会将数据从低层次缓存中以固定的“块大小（通常为缓存行大小）”为单位，拷贝到高层次缓存中。而为了减少 CPU 需要进行的内存拷贝次数，我们希望连续的数据能被组织在尽可能少的缓存行中。另一方面，内存与高速缓存之间的映射关系一般与数据在内存中的具体地址有关。比如，对于采用“直接映射”方式的缓存来说，假设缓存行大小为 64 字节，若某段数据起始于内存中对齐到 64 字节的地址，而当它被拷贝到高速缓存中时，便会从缓存行的开头处开始放置数据，这在最大程度上减少了这段连续数据需要占用的缓存行个数（当从缓存行中间开始存放数据时，字段 y 可能需要占用三个缓存行）。



## 代码内联

C99 标准引入了一个名为 inline 的关键字，通过该关键字，我们可以建议编译器，将某个方法的实现内联到它的实际调用处。

 

## restrict 关键字

C99 标准新增了一个名为 restrict 的关键字，可以优化代码的执行。该关键字只能用于指针类型，用以表明该指针是访问对应数据的唯一方式。在计算机领域，有一个名为 aliasing 的概念。这个概念是说内存中的某一个位置，可以通过程序中多于一个的变量来访问或修改其包含的数据。而这可能会导致一个潜在的问题：即当通过其中的某个变量修改数据时，便会导致所有与其他变量相关的数据访问发生改变。因此，aliasing 使得编译器难以对程序进行过多的优化。而在 C 语言中，restrict 关键字便可以解决这个问题。当然，如果你学习过 Rust，这也是其所有权机制的核心内容。



## 消除不必要的内存引用

## 循环展开（Loop Unrolling）

 为了让你更好地理解“循环展开”这个优化技巧背后的原理，我们先从宏观角度看看 CPU 是如何运作的。早期的 CPU 在执行指令时，是以串行的方式进行的，也就是说，一个指令的执行开始，需要等待前一个指令的执行完全结束。这种方式在实现上很简单，但存在的问题也十分明显：由于指令的执行是一个涉及多个功能单元的复杂过程，而在某一时刻，CPU 也只能够对指令进行针对当前所在阶段的特定处理。那么，将 CPU 处理指令的流程划分为不同阶段，并让它对多条指令同时进行多种不同处理，这样是否可以进一步提升 CPU 的吞吐量呢？事实正是如此。现代 CPU 为了进一步提升指令的执行效率，通常会将单一的机器指令再进行拆分，以达到指令级并行的目的。比如，对于一个基本的五级 RISC 流水线来说，CPU 会将指令的执行细分为指令提取（IF）、指令译码（ID）、指令执行（EX）、内存访问（MEM），以及寄存器写回（WB）共五个步骤。在这种情况下，当第一条机器指令经过了指令提取阶段的处理后，即使该条指令还没有被完全执行完毕，CPU 也可以立即开始处理下一条机器指令。因此，从宏观上来看，机器指令的执行由串行变为了并行，程序的执行效率得到了提升。其中，指令提取是指从内存中读取出机器指令字节的过程。CPU 根据得到的指令字节，在译码阶段，从相应的寄存器中获得指令执行所需要的参数。而在执行阶段，ALU 可以选择执行指令明确的操作，或者是计算相关内存引用的有效地址等操作。随后，在访存阶段，根据指令要求，CPU 可以将数据写回内存，或从内存中读出所需数据。类似地，在写回阶段，CPU 可以将指令执行得到的结果存入寄存器。

## 优先使用条件传送指令
