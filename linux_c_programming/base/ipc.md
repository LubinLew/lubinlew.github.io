# 进程间通信

- 管道
- 消息队列
- 共享内存
- 信号量
- 信号
- 套接字(Socket)

## 管道

### 匿名管道

```c
#include <unistd.h>

int pipe(int fildes[2]);
```

只能用于具有共同祖先的进程(具有亲缘关系的进程)之间进行通信；
通常一个管道由一个进程创建，然后进程调用fork，父子进程之间就可以进程通信了。
管道提供流式服务，就是一个数据一个数据传，相比较数据包，多个数据构成数据包，以整个数据包为单位。
进程退出管道释放，管道声明周期随进程的。
内核对管道的操作式同步和互斥的。同步一个进程快，另外一个也快，一个慢，另外一个也慢。
互斥是，一个再写，另外一个不会正好读，一个在读，不会另外一个进程正好写。
管道是半双工的，数据只能一个方向流动，需要双方通信时，需要建立两个管道。

### 命名管道

```c
#include <sys/types.h>
#include <sys/stat.h>

int mkfifo(const char *pathname, mode_t mode);
```

命名管道可以用于不相关的两进程之间进行通信。

只是需要先创建一个命名管道。再一个进程以读或者写的方式来打开该管道文件，
再另外一个进程不需要创建管道，只需要以写或者读的方式来打开管道文件。
再调用读写系统调用来往文件写或者读，来进行进程间通信。

两进程分别对同一管道文件分别用读或写的方式打开，两进程看到同一文件(资源)。

## 消息队列

> https://www.cnblogs.com/LubinLew/p/POSIX-MessageQueue.html

### DESCRIPTION

消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息，这和大多数通信协议是不同的。
但消息队列的异步特点，也造成了一个缺点，就是接收者必须轮询消息队列，才能收到最近的消息。
和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据，但仍然有大小限制。

POSIX消息队列允许进程间以消息的形式交换数据.
POSIX消息队API与System V消息队列的API不同, 但是功能是相似的.

使用 `mq_open(3)` 创建和打开消息队列; 这个函数的返回值是一个消息队列描述符 (mqd_t), 
这个描述符会在之后操作对应的消息队列时候用到.

每一个消息队列都有一个名字,名字的形式是 "/somename",是一个以NULL结尾的字符串,字符串的最大长度为NAME_MAX (i.e., 255);

消息队列名字的第一个字符必须是"/",并且之后的字符中不允许出现"/"。2个进程可以通过相同的name操作同一个的消息队列。

使用 `mq_send(3)` 可以向消息队列中发送消息，使用 `mq_receive(3)` 可以从消息队列中读取消息

当一个进程使用完一个消息队列后，调用 `mq_close(3)` 来关闭这个队列,

如果以后再也不使用这个队列了，可以调用 `mq_unlink(3)`来删除这个队列。

消息队列的属性可以通过 `mq_getattr(3)` 来获得，某些情况下这个API也可以修改消息队列的属性.

进程可以调用API `mq_notify(3)` 注册一个异步的通知，通知的触发时机是空消息队列中有消息到达时.

一个消息队列描述符是对一个打开的消息队列的引用(cf. open(2)).

## 共享内存

> https://www.cnblogs.com/LubinLew/p/POSIX-shared_memory.html

### DESCRIPTION

共享内存是最快的可用IPC形式。
它允许多个不相关(无亲缘关系)的进程去访问同一部分逻辑内存。
如果需要在两个进程之间传输数据，共享内存将是一种效率极高的解决方案。
一旦这样的内存区映射到共享它的进程的地址空间，这些进程间数据的传输就不再涉及内核。
这样就可以减少系统调用时间，提高程序效率。

共享内存是由IPC为一个进程创建的一个特殊的地址范围，
它将出现在进程的地址空间中。其他进程可以把同一段共享内存段“连接到”它们自己的地址空间里去。
所有进程都可以访问共享内存中的地址。
如果一个进程向这段共享内存写了数据，所做的改动会立刻被有访问同一段共享内存的其他进程看到。

要注意的是共享内存本身没有提供任何同步功能。
也就是说，在第一个进程结束对共享内存的写操作之前，并没有什么自动功能能够预防第二个进程开始对它进行读操作。
共享内存的访问同步问题必须由程序员负责。可选的同步方式有互斥锁、条件变量、读写锁、纪录锁、信号灯。

实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止。

## 信号量

> https://www.cnblogs.com/LubinLew/p/POSIX-semaphores.html

### DESCRIPTION

POSIX 信号量允许进程间和线程间同步他们的操作. 
一个信号量是一个整型(integer),其值不能小于0. 
信号量允许2种操作:给信号量的值加1(sem_post); 给信号量的值减一(sem_wait).

如果信号量的值为0, 那么sem_wait() 函数将会阻塞, 直到信号量的值大于0才会解除阻塞. 

POSIX 信号量有两种形式: 有名信号量 和 无名信号量.

### Named semaphores

一个有名信号量有一个唯一的名字, 名字的格式是 `/somename`; 
名字是以NULL结尾的字符串,最大长度不超过NAME_MAX-4 (减4的原因见Accessing named semaphores via the filesystem) 个字节(包括最前面的斜线),
除了首个字节是斜线外,之后的任何字节都不能是斜线.

两个进程可以通过给 `sem_open()` 函数传递相同名字来达到操作同一个信号量的目的.
函数`sem_open()` 可以创建一个新的有名的信号量 或者 打开一个既存的有名信号量. 
信号量被打开后, 就可以使用函数 `sem_post()` 和 `sem_wait()` 来操作它.

当一个进程使用完了这个信号量后,他可以使用函数 `sem_close()` 来关闭这个信号量.

当所有的进程都不再使用这个信号量时,可以调用函数 `sem_unlink()` 将这个信号量从系统中删除.

### Unnamed semaphores (memory-based semaphores)

无名信号量没有名字, 作为代替有名的方法,无名信号量被放置于一个多线程共享的内存区域中(线程共享的信号量) 或者多个进程共享的内存区域中(进程共享的信号量).
线程共享的信号量被放置于一个进程之内的多线程共享内存区,例如全局变量.
进程共享信号量必须被放置于共享内存中(例如使用shm_open()创建的共享内存对象).
在使用无名信号量之前, 必须使用函数 `sem_init()` 初始化这个无名信号量, 随后才可以使用 `sem_post()` 和 `sem_wait()` 来操作这个无名信号量.
当无名信号量不在使用时, 并且信号量所在的内存区域没有被释放, 使用 `sem_destroy()` 来删除这个无名信号量.