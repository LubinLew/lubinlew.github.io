# Linux 设备

### Character devices

*Character special files* or *character devices* provide unbuffered, direct access to the hardware device. They do not necessarily allow programs to read or write single characters at a time; that is up to the device in question. The character device for a hard disk, for example, will normally require that all reads and writes be aligned to block boundaries and most certainly will not allow reading a single byte.

Character devices are sometimes known as *raw devices* to avoid the confusion surrounding the fact that a character device for a piece of block-based hardware will typically require programs to read and write aligned blocks.

### Block devices

*Block special files* or *block devices* provide buffered access to hardware devices, and provide some abstraction from their specifics.[[6]](https://en.wikipedia.org/wiki/Device_file#cite_note-6) Unlike character devices, block devices will always allow the programmer to read or write a block of any size (including single characters/bytes) and any alignment. The downside is that because block devices are buffered, the programmer does not know how long it will take before written data is passed from the kernel's buffers to the actual device, or indeed in what order two separate writes will arrive at the physical device. Additionally, if the same hardware exposes both character and block devices, there is a risk of data corruption due to clients using the character device being unaware of changes made in the buffers of the block device.

Most systems create both block and character devices to represent hardware like hard disks. FreeBSD and Linux notably do not; the former has removed support for block devices,[[7]](https://en.wikipedia.org/wiki/Device_file#cite_note-7) while the latter creates only block devices. In Linux, to get a character device for a disk, one must use the "raw" driver, though one can get the same effect as opening a character device by opening the block device with the Linux-specific O_DIRECT flag.

### Pseudo-devices

Device nodes on Unix-like systems do not necessarily have to correspond to [physical devices](https://en.wikipedia.org/wiki/Physical_device "Physical device"). Nodes that lack this correspondence form the group of *pseudo-devices*. They provide various functions handled by the operating system. Some of the most commonly used (character-based) pseudo-devices include:

- [/dev/null](https://en.wikipedia.org/wiki//dev/null "/dev/null") – accepts and discards all input written to it; provides an [end-of-file](https://en.wikipedia.org/wiki/End-of-file "End-of-file") indication when read from.
- [/dev/zero](https://en.wikipedia.org/wiki//dev/zero "/dev/zero") – accepts and discards all input written to it; produces a continuous stream of [null characters](https://en.wikipedia.org/wiki/Null_character "Null character") (zero-value bytes) as output when read from.
- [/dev/full](https://en.wikipedia.org/wiki//dev/full "/dev/full") – produces a continuous stream of null characters (zero-value bytes) as output when read from, and generates an [ENOSPC](https://en.wikipedia.org/wiki/Errno.h "Errno.h") ("disk full") error when attempting to write to it.
- [/dev/random](https://en.wikipedia.org/wiki//dev/random "/dev/random") – produces bytes generated by the kernel's [cryptographically secure pseudorandom number generator](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator "Cryptographically secure pseudorandom number generator"). Its exact behavior varies by implementation, and sometimes variants such as /dev/urandom or /dev/arandom are also provided.

Additionally, BSD-specific pseudo-devices with an [ioctl](https://en.wikipedia.org/wiki/Ioctl "Ioctl") interface may also include:

- [/dev/pf](https://en.wikipedia.org/wiki//dev/pf "/dev/pf") – allows userland processes to control [PF](https://en.wikipedia.org/wiki/PF_(firewall) "PF (firewall)") through an ioctl interface.
- [/dev/bio](https://en.wikipedia.org/wiki//dev/bio "/dev/bio") – provides ioctl access to devices otherwise not found as /dev nodes, used by [bioctl](https://en.wikipedia.org/wiki/Bioctl "Bioctl") to implement [RAID](https://en.wikipedia.org/wiki/RAID "RAID") management in [OpenBSD](https://en.wikipedia.org/wiki/OpenBSD "OpenBSD") and [NetBSD](https://en.wikipedia.org/wiki/NetBSD "NetBSD").
- [/dev/sysmon](https://en.wikipedia.org/wiki//dev/sysmon "/dev/sysmon") – used by NetBSD's [envsys](https://en.wikipedia.org/wiki/Envsys "Envsys") framework for [hardware monitoring](https://en.wikipedia.org/wiki/System_monitor "System monitor"), accessed in the userland through [proplib(3)](https://en.wikipedia.org/wiki/Proplib(3) "Proplib(3)") by the envstat utility.[[8]](https://en.wikipedia.org/wiki/Device_file#cite_note-envstat-8)

### Node creation

Nodes are created by the mknod [system call](https://en.wikipedia.org/wiki/System_call "System call"). The command-line program for creating nodes is also called mknod. Nodes can be moved or deleted by the usual filesystem system calls ([rename](https://en.wikipedia.org/wiki/Rename_(computing) "Rename (computing)"), [unlink](https://en.wikipedia.org/wiki/Unlink_(Unix) "Unlink (Unix)")) and [commands](https://en.wikipedia.org/wiki/Command_(computing) "Command (computing)") ([mv](https://en.wikipedia.org/wiki/Mv_(Unix) "Mv (Unix)"), [rm](https://en.wikipedia.org/wiki/Rm_(Unix) "Rm (Unix)")).

Some Unix versions include a script named *makedev* or *MAKEDEV* to create all necessary devices in the directory /dev. It only makes sense on systems whose devices are statically assigned major numbers (e.g., by means of hardcoding it in their kernel module).

While some other Unix systems such as [FreeBSD](https://en.wikipedia.org/wiki/FreeBSD "FreeBSD"), used kernel-based device node management via devfs only, and not supporting manual node creation. mknod(2) system call and mknod(8) command exist to keep compatibility with POSIX, but manually created device nodes outside devfs will not function at all.[[9]](https://en.wikipedia.org/wiki/Device_file#cite_note-9)

### Naming conventions

The following prefixes are used for the names of some devices in the /dev hierarchy, to identify the type of device:

- lp: [line printers](https://en.wikipedia.org/wiki/Line_printer "Line printer") (compare [lp](https://en.wikipedia.org/wiki/Lp_(Unix) "Lp (Unix)"))
- pt: [pseudo-terminals](https://en.wikipedia.org/wiki/Pseudo_terminal "Pseudo terminal") (virtual terminals)
- tty: [terminals](https://en.wikipedia.org/wiki/Computer_terminal "Computer terminal")

Some additional prefixes have come into common use in some operating systems:

- fb: [frame buffer](https://en.wikipedia.org/wiki/Frame_buffer "Frame buffer")
- fd: (platform) [floppy disks](https://en.wikipedia.org/wiki/Floppy_disk "Floppy disk"), though this same abbreviation is also commonly used to refer to [file descriptor](https://en.wikipedia.org/wiki/File_descriptor "File descriptor")
- hd: ("classic") [IDE](https://en.wikipedia.org/wiki/Integrated_Drive_Electronics "Integrated Drive Electronics") driver (previously used for ATA [hard disk drive](https://en.wikipedia.org/wiki/Hard_disk_drive "Hard disk drive"), ATAPI [optical disc drives](https://en.wikipedia.org/wiki/Optical_disc_drive "Optical disc drive"), etc.)
  - hda: the master device on the first [ATA channel](https://en.wikipedia.org/wiki/ATA_channel "ATA channel") (usually identified by major number 3 and minor number 0)
  - hdb: the slave device on the first ATA channel
  - hdc: the master device on the second ATA channel
  - hdd: the slave device on the second ATA channel
- parport, pp: [parallel ports](https://en.wikipedia.org/wiki/Parallel_port "Parallel port")
- mem: [Main memory](https://en.wikipedia.org/wiki/Main_memory "Main memory") (character device)
- [NVMe](https://en.wikipedia.org/wiki/NVM_Express "NVM Express") driver:
  - nvme0: first registered device's device controller (character device)
  - nvme0n1: first registered device's first namespace (block device)
  - nvme0n1p1: first registered device's first namespace's first partition (block device)
- [MMC](https://en.wikipedia.org/wiki/MultiMediaCard "MultiMediaCard") driver:
  - mmcblk: storage driver for [MMC](https://en.wikipedia.org/wiki/MultiMediaCard "MultiMediaCard") media ([SD](https://en.wikipedia.org/wiki/SD_card "SD card") cards, eMMC chips on laptops, etc.)
    - mmcblk0: first registered device
    - mmcblk0p1: first registered device's first partition
- [SCSI](https://en.wikipedia.org/wiki/SCSI "SCSI") driver, also used by [libATA](https://en.wikipedia.org/wiki/LibATA "LibATA") (modern [PATA](https://en.wikipedia.org/wiki/Parallel_ATA "Parallel ATA")/[SATA](https://en.wikipedia.org/wiki/Serial_ATA "Serial ATA") driver), [USB](https://en.wikipedia.org/wiki/Universal_Serial_Bus "Universal Serial Bus"), [IEEE 1394](https://en.wikipedia.org/wiki/IEEE_1394 "IEEE 1394"), etc.:
  - sd: mass-storage driver (block device)
    - sda: first registered device
    - sdb, sdc, etc.: second, third, etc. registered devices
  - ses: Enclosure driver
  - sg: generic SCSI layer
  - sr: "ROM" driver (data-oriented optical disc drives; scd is just a secondary alias)
  - st: [magnetic tape](https://en.wikipedia.org/wiki/Magnetic_tape "Magnetic tape") driver
- tty: [terminals](https://en.wikipedia.org/wiki/Computer_terminal "Computer terminal")
  - ttyS: (platform) [serial port](https://en.wikipedia.org/wiki/Serial_port "Serial port") driver
  - ttyUSB: USB serial converters, modems, etc.

The canonical list of the prefixes used in Linux can be found in the Linux Device List, the official registry of allocated device numbers and /dev directory nodes for the Linux operating system.[[10]](https://en.wikipedia.org/wiki/Device_file#cite_note-10)

For most devices, this prefix is followed by a number uniquely identifying the particular device. For hard drives, a letter is used to identify devices and is followed by a number to identify [partitions](https://en.wikipedia.org/wiki/Disk_partitioning "Disk partitioning"). Thus a file system may "know" an area on a disk as /dev/sda3, for example, or "see" a networked terminal session as associated with /dev/pts/14.

On disks using the typical PC [master boot record](https://en.wikipedia.org/wiki/Master_boot_record "Master boot record"), the device numbers of primary and the optional extended partition are numbered 1 through 4, while the indexes of any logical partitions are 5 and onwards, regardless of the layout of the former partitions (their parent extended partition does not need to be the fourth partition on the disk, nor do all four primary partitions have to exist).

Device names are usually not portable between different Unix-like system variants, for example, on some [BSD](https://en.wikipedia.org/wiki/BSD "BSD") systems, the IDE devices are named /dev/wd0, /dev/wd1, etc.

### devfs

**devfs** is a specific implementation of a device file system on Unix-like operating systems, used for presenting device files. The underlying mechanism of implementation may vary, depending on the OS.

Maintaining these special files on a *physically* implemented file system (i.e., hard drive) is inconvenient, and as it needs kernel assistance anyway, the idea arose of a special-purpose *logical* file system that is not physically stored.

Also, defining when devices are ready to appear is not entirely trivial. The devfs approach is for the device driver to request creation and deletion of devfs entries related to the devices it enables and disables.



## 参考链接

[Device file - Wikipedia](https://en.wikipedia.org/wiki/Device_file)

[技术|诠释 Linux 中“一切都是文件”概念和相应的文件类型](https://linux.cn/article-7669-1.html)
