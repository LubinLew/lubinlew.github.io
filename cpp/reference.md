# 引用

```cpp
&  attr ﻿(optional) declarator    (1)    
&& attr ﻿(optional) declarator    (2)    (since C++11)
```

## 引用的类型

- 左值引用: `S&  D`; 声明 D 是类型 S 的左值引用
- 右值引用: `S&& D`; 声明 D 是类型 S 的右值引用

> [C++中左值（引用）及右值（引用）详解](https://blog.csdn.net/weixin_43064827/article/details/120803409)
> 
> - 左值：在内存有确定存储地址、有变量名，表达式结束依然存在的值，简单来说左值就是非临时对象。
> 
> - 右值：就是在内存没有确定存储地址、没有变量名，表达式结束就会销毁的值，简单来说右值就是临时对象。
> 
> - 左值引用：绑定到左值的引用，通过`&`来获得左值引用。
> 
> - 右值引用：绑定到右值的引用，通过`&&`来获得右值引用。

### 右值引用与左值引用的区别

- 1、左值引用绑定到有确定存储空间以及变量名的对象上，表达式结束后对象依然存在；

- 2、右值引用绑定到要求转换的表达式、字面常量、返回右值的表达式等临时对象上，赋值表达式结束后就对象就会被销毁。

- 3、左值引用后可以利用别名修改左值对象；右值引用绑定的值不能修改。

### 引入右值引用的原因

- 1、替代需要销毁对象的拷贝，提高效率：某些情况下，需要拷贝一个对象然后将其销毁，如：临时类对象的拷贝就要先将旧内存的资源拷贝到新内存，然后释放旧内存，引入右值引用后，就可以让新对象直接使用旧内存并且销毁原对象，这样就减少了内存和运算资源的使用，从而提高了运行效率；

- 2、移动含有不能共享资源的类对象：像IO、unique_ptr这样的类包含不能被共享的资源（如：IO缓冲、指针），因此，这些类对象不能拷贝但可以移动。这种情况，需要先调用std::move将左值强制转换为右值，再进行右值引用。

### 转换

C++11中提供了一个标准库`move`函数获得绑定到左值上的右值引用，即直接调用`std::move`告诉编译器将左值像对待同类型右值一样处理，但是被调用后的左值将不能再被使用。